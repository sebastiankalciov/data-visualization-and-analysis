"id","title_ger","title_eng","task_description_tex_ger","task_description_plain_ger","task_description_plain_eng","skeleton","tester","answer"
"21_22-1-1-python","Divide and Conquer Rekurrenz [Python]","Divide and Conquer Recurrence [Python]","Input: \(n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}\)~

Output:~ \(a_{n_0} \; mod \; 10^9+7\) mit
\(a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0\)

Berechnen Sie in \(O(\: log \: n)\) den Output für einen beliebigen
Input in der Funktion ""def calc(n):"" was nur ein Integer als Parameter
entgegen nimmt.~ Für die Implementation dürfen Sie weder das Keyword
""import"", ""**"", ""eval"" ,""checkCalc"", ""globals"",""pow"" oder ""expo""
verwenden.

Für leichteres Debugging können Sie Ihr Ergebnis in jedem Rechenschritt
durch modulo \(10^9+7\) teilen. Zum Beispiel:

def calc(a,b,c):

~ ~ res = (a+b) \% 1000000007

~ ~ res = (res+c) \% 1000000007

~ ~ return (res+1000) \% 1000000007

\hfill\break

Hinweise:

1. Finden Sie eine geschlossene Form für die Rekurrenz.

2. Nutzen Sie ""//"" (ohne die Anführungszeichen) um integer Division in
Python durchzuführen und Floats zu vermieden.

3. Falls \(b\) gerade ist gilt:

\(a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}\)

Falls \(b\) ungerade ist gilt:

\(a^b = a^{b-1} \cdot a\)~~
","Input: $n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}$ 

Output:  $a_{n_0} \; mod \; 10^9+7$ mit
$a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0$

Berechnen Sie in $O(\: log \: n)$ den Output für einen beliebigen Input
in der Funktion ""def calc(n):"" was nur ein Integer als Parameter
entgegen nimmt.  Für die Implementation dürfen Sie weder das Keyword
""import"", ""**"", ""eval"" ,""checkCalc"", ""globals"",""pow"" oder ""expo""
verwenden.

Für leichteres Debugging können Sie Ihr Ergebnis in jedem Rechenschritt
durch modulo $10^9+7$ teilen. Zum Beispiel:

def calc(a,b,c):

    res = (a+b) % 1000000007

    res = (res+c) % 1000000007

    return (res+1000) % 1000000007

Hinweise:

1. Finden Sie eine geschlossene Form für die Rekurrenz.

2. Nutzen Sie ""//"" (ohne die Anführungszeichen) um integer Division in
Python durchzuführen und Floats zu vermieden.

3. Falls $b$ gerade ist gilt:

$a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}$

Falls $b$ ungerade ist gilt:

$a^b = a^{b-1} \cdot a$  
","Input: $n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}$ 

Output: $a_{n_0} \; mod \; 10^9+7$ with
$a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0$

Calculate in $O(\: log \: n)$ the output for any input
in the function ""def calc(n):"" that takes only an integer as a parameter.
For the implementation you must not use the keyword
""import"", ""**"", ""eval"" , ""checkCalc"", ""globals"", ""pow"" or ""expo"".

For easier debugging, you can divide your result in each calculation step by modulo $10^9+7$. For example:

def calc(a,b,c):

    res = (a+b) % 10000007

    res = (res+c) % 10000007

    return (res+1000) % 10000007

Hints:

1. Find a closed form for the recurrence.

2. Use ""//"" (without the quotation marks) to perform integer division in
Python and to avoid floats.

3. If $b$ is even, then:

$a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}$

If $b$ is odd, then:

$a^b = a^{b-1} \cdot a$  
","def calc(n):
    pass","from random import randint

def checkCalc(n):
    a = 2; b = n; c = 1000000007
    return checkExpo(a,b,c) - 1
def checkExpo(a,b,c):
    if b == 0:
        return 1 % c
    elif b % 2:
        return (a * checkExpo(a,b-1,c)) % c
    else:
        a = checkExpo(a,b // 2,c) % c
        return (a*a) % c

{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

        
{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def calc(n):
    a = 2; b = n; c = 1000000007
    return expo(a,b,c) - 1
def expo(a,b,c):
    if b == 0:
        return 1 % c
    elif b % 2:
        return (a * expo(a,b-1,c)) % c
    else:
        a = expo(a,b // 2,c) % c
        return (a*a) % c"
"21_22-1-2-python","Divide and Conquer Funktion [Python]","Divide and Conquer Function [Python]","Sei \(N \in \mathbb{N} \land N \leq 10^{18}\) und
\(f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \\ 0, & \text { if }  n < N \end{cases}\)
eine binäre Funktion, wobei \(N\) unbekannt ist. Ziel der Aufgabe ist
\(N\)~ in \(O(log \: n)\) zu ermitteln.

Input: Eine binäre Funktion \(f_N\), wobei \(N\) unbekannt ist.

Output:~ \(N\).

Die Funktion \(f_N\) ist als Argument verfügbar in der
Implementation.~~Für die Implementation dürfen Sie weder das Keyword
""import"" , ""globals"" oder ""eval""~ verwenden. Berechnen Sie den Output
in~\(O(log \: n)\) in der Funktion ""calc(f)"".

Hinweise:

1. Analysieren Sie das Monotonieverhalten der Funktion.

2. Sei \(x \in \mathbb{N}\) mit \(f_N(x) = 0\). Was wissen wir für alle
Werte \(y \in \mathbb{N}, y < x\)? Sei nun \(f_N(x) = 1\). Was wissen
wir für alle Werte \(z \in \mathbb{N}, x < z\)?
","Sei $N \in \mathbb{N} \land N \leq 10^{18}$ und
$f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \\ 0, & \text { if }  n < N \end{cases}$
eine binäre Funktion, wobei $N$ unbekannt ist. Ziel der Aufgabe ist $N$ 
in $O(log \: n)$ zu ermitteln.

Input: Eine binäre Funktion $f_N$, wobei $N$ unbekannt ist.

Output:  $N$.

Die Funktion $f_N$ ist als Argument verfügbar in der
Implementation.  Für die Implementation dürfen Sie weder das Keyword
""import"" , ""globals"" oder ""eval""  verwenden. Berechnen Sie den Output
in $O(log \: n)$ in der Funktion ""calc(f)"".

Hinweise:

1. Analysieren Sie das Monotonieverhalten der Funktion.

2. Sei $x \in \mathbb{N}$ mit $f_N(x) = 0$. Was wissen wir für alle
Werte $y \in \mathbb{N}, y < x$? Sei nun $f_N(x) = 1$. Was wissen wir
für alle Werte $z \in \mathbb{N}, x < z$?
","Let $N \in \mathbb{N} \land N \leq 10^{18}$ and
$f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \ 0, & \text { if } n < N \end{cases}$
a binary function, where $N$ is unknown. The goal of the task is to calculate $N$ 
in $O(log \: n)$.

Input: A binary function $f_N$, where $N$ is unknown.

Output: $N$.

The function $f_N$ is available as argument in the
implementation.  For the implementation you must not use the keyword
""import"" , ""globals"" or ""eval"". Calculate the output
in $O(log \: n)$ in the function ""calc(f)"".

Hints:

1. Analyze the monotonicity of the function.

2. Let $x \in \mathbb{N}$ with $f_N(x) = 0$. What do we know for all
values $y \in \mathbb{N}, y < x$? Now let $f_N(x) = 1$. What do we know
for all values $z \in \mathbb{N}, x < z$?
","def calc(f):
    pass","from random import randint

{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def calc(f):
    l = 0
    r = 10**(18)
    while 0 <= l <= r:
        m = ((r + l) // 2)
        #print(m)
        if f(m):
            r = m - 1
        else:
            l = m + 1
    if f(m):
        return m
    else:
        return m + 1"
"21_22-1-1-java","Divide and Conquer Rekurrenz [Java]","Divide and Conquer Recurrence [Java]","Input: \(n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}\)~

Output:~ \(a_{n_0} \; mod \; 10^9+7\) mit
\(a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0\)

Berechnen Sie in \(O(\: log \: n)\) den Output für einen beliebigen
Input in der Funktion ""long calc(n)"" mit einem Integer Parameter/long
Parameter . Für die Implementation dürfen Sie weder das Keyword
""import"", ""**"", ""eval"" ,""checkCalc"" oder ""expo"" verwenden.

Für leichteres Debugging können Sie Ihr Ergebnis in jedem Rechenschritt
durch modulo \(10^9+7\) teilen. Zum Beispiel:

long calc(long a,long b,long c)\{

~ ~ long res = (a+b) \% 1000000007;

~ ~ res = (res+c) \% 1000000007;

~ ~ return (res+1000) \% 1000000007;

\}

Hinweise:

1. Finden Sie eine geschlossene Form für die Rekurrenz.

2. Nutzen Sie integer Division und Floats vermieden.

3. Falls \(b\) gerade ist gilt:

\(a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}\)

Falls \(b\) ungerade ist gilt:

\(a^b = a^{b-1} \cdot a\)~~
","Input: $n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}$ 

Output:  $a_{n_0} \; mod \; 10^9+7$ mit
$a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0$

Berechnen Sie in $O(\: log \: n)$ den Output für einen beliebigen Input
in der Funktion ""long calc(n)"" mit einem Integer Parameter/long
Parameter . Für die Implementation dürfen Sie weder das Keyword
""import"", ""**"", ""eval"" ,""checkCalc"" oder ""expo"" verwenden.

Für leichteres Debugging können Sie Ihr Ergebnis in jedem Rechenschritt
durch modulo $10^9+7$ teilen. Zum Beispiel:

long calc(long a,long b,long c){

    long res = (a+b) % 1000000007;

    res = (res+c) % 1000000007;

    return (res+1000) % 1000000007;

}

Hinweise:

1. Finden Sie eine geschlossene Form für die Rekurrenz.

2. Nutzen Sie integer Division und Floats vermieden.

3. Falls $b$ gerade ist gilt:

$a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}$

Falls $b$ ungerade ist gilt:

$a^b = a^{b-1} \cdot a$  
","Input: $n_0 \in \mathbb{N}_0: \; 0 \leq n_0 \leq 10^{9}$ 

Output: $a_{n_0} \; mod \; 10^9+7$ with
$a_{n+1}=2 a_{n}+1 \; \; n \in \mathbb{N}_0, a_{0}=0$

Calculate in $O(\: log \: n)$ the output for any input
in the function ""long calc(n)"" with an integer parameter/long
parameter . For the implementation you must not use the keyword
""import"", ""**"", ""eval"" , ""checkCalc"" or ""expo"".

For easier debugging, you can divide your result in each calculation step by modulo $10^9+7$. For example:

long calc(long a,long b,long c){

    long res = (a+b) % 1000000007;

    res = (res+c) % 1000000007;

    return (res+1000) % 1000000007;

}

Hints:

1. Find a closed form for the recurrence.

2. Use integer divison and floats avoided.

3. If $b$ is even, then:

$a^b = (a^{\frac{b}{2}})^2 = a^{\frac{b}{2}} \cdot a^{\frac{b}{2}}$

If $b$ is odd, then:

$a^b = a^{b-1} \cdot a$  ","long calc(long n){
    return (n+1000) % 1000000007;
}","public class __tester__ {
    public static long checkCalc(long n){
        long  a = 2, b = n, c = 1000000007;
        return checkExpo(a,b,c) - 1;
        }

    public static long checkExpo(long a,long b,long c){
        if (b == 0)
            return 1;
        else if (b % 2 == 1)
            return (a * checkExpo(a,b-1,c)) % c;
        else{
            a = checkExpo(a,b / 2,c);
            return (a*a) % c;
        }
    }
        
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}

    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }


    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","long calc(long n){
    long  a = 2, b = n, c = 1000000007;
    return expo(a,b,c) - 1;
}

long expo(long a,long b,long c){
    if (b == 0)
        return 1;
    else if (b % 2 == 1)
        return (a * expo(a,b-1,c)) % c;
    else{
        a = expo(a,b / 2,c);
        return (a*a) % c;
    }
}"
"21_22-1-2-java","Divide and Conquer Funktion [Java]","Divide and Conquer Function [Java]","Sei \(N \in \mathbb{N} \land N \leq 10^{18}\) und
\(f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \\ 0, & \text { if }  n < N \end{cases}\)
eine binäre Funktion, wobei \(N\) unbekannt ist. Ziel der Aufgabe ist
\(N\)~ in \(O(log \: n)\) zu ermitteln.

Input: Eine binäre Funktion \(f_N\), wobei \(N\) unbekannt ist.

Output:~ \(N\).

Die Funktion \(f_N\) ist als Argument verfügbar in der
Implementation.~~Für die Implementation dürfen Sie weder das Keyword
""import"" oder ""eval""~ verwenden. Berechnen Sie den Output
in~\(O(log \: n)\) in der Funktion ""calc(f)"".\\
\strut \\
Die funktions name im code ist ""f\_N(n)"" und gibt 0 oder 1 zurück\\

Hinweise:

1. Analysieren Sie das Monotonieverhalten der Funktion.

2. Sei \(x \in \mathbb{N}\) mit \(f_N(x) = 0\). Was wissen wir für alle
Werte \(y \in \mathbb{N}, y < x\)? Sei nun \(f_N(x) = 1\). Was wissen
wir für alle Werte \(z \in \mathbb{N}, x < z\)?
","Sei $N \in \mathbb{N} \land N \leq 10^{18}$ und
$f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \\ 0, & \text { if }  n < N \end{cases}$
eine binäre Funktion, wobei $N$ unbekannt ist. Ziel der Aufgabe ist $N$ 
in $O(log \: n)$ zu ermitteln.

Input: Eine binäre Funktion $f_N$, wobei $N$ unbekannt ist.

Output:  $N$.

Die Funktion $f_N$ ist als Argument verfügbar in der
Implementation.  Für die Implementation dürfen Sie weder das Keyword
""import"" oder ""eval""  verwenden. Berechnen Sie den Output
in $O(log \: n)$ in der Funktion ""calc(f)"".
Die funktions name im code ist ""f_N(n)"" und gibt 0 oder 1 zurück

Hinweise:

1. Analysieren Sie das Monotonieverhalten der Funktion.

2. Sei $x \in \mathbb{N}$ mit $f_N(x) = 0$. Was wissen wir für alle
Werte $y \in \mathbb{N}, y < x$? Sei nun $f_N(x) = 1$. Was wissen wir
für alle Werte $z \in \mathbb{N}, x < z$?
","Let $N \in \mathbb{N} \land N \leq 10^{18}$ and
$f_N:\mathbb{N}_0 \mapsto \{0,1\}, \; n \mapsto \begin{cases}1, & \text { if } n \geq N \ 0, & \text { if } n < N \end{cases}$
a binary function, where $N$ is unknown. The goal of the task is $N$ 
in $O(log \: n)$.

Input: a binary function $f_N$, where $N$ is unknown.

Output: $N$.

The function $f_N$ is available as argument in the
implementation.  For the implementation you must not use the keyword
""import"" or ""eval"". Calculate the output
in $O(log \: n)$ in the function ""calc(f)"".
The function name in the code is ""f_N(n)"" and returns 0 or 1

Hints:

1. Analyze the monotonicity of the function.

2. Let $x \in \mathbb{N}$ with $f_N(x) = 0$. What do we know for all
values $y \in \mathbb{N}, y < x$? Now let $f_N(x) = 1$. What do we know
for all values $z \in \mathbb{N}, x < z$?","long calc(){
    
    
}","public class __tester__ {
    public static long N = 0;
    public static int f_N(long n){
        return (n>=N? 1 : 0);
    }
    
    
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}

    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }

    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","long calc(){
    long l = 0;
    long r = Long.parseUnsignedLong(""1000000000000000000"");
    long m = ((r + l) / 2);
    while (0 <= l && l <= r){
        m = ((r + l) / 2);
        
        if (f_N(m) != 0)
            r = m - 1;
        else
            l = m + 1;
    }
    if (f_N(m) != 0)
        return m;
    else
        return m + 1;
}"
"21_22-2-1-python","Logistik am Nordpol (Python)","Logistics at the North Pole (Python)","Es ist Weihnachten und dem Weihnachtsmann bleibt wenig Zeit: Er muss
sich ein System ausdenken womit er alle Geschenke rechtzeitig ausliefern
kann. Dafür nutzt er das folgende System: Zuerst werden alle
Kuscheltiere ausgeliefert, dann alle Bücher, usw. Die Kategorie des
\(i-\)ten Geschenkes ist~\(A[i]\). Leider hat der~Schlit­ten des
Weihnachtsmanns keine unendliche große Kapizität: Für Objekte der
Kategorie~\(i\) hat der Schlitten von dem Weinhnachtsmann eine maximale
Kapazität von~\(B[ i]\). Nun möchte er wissen, ob es möglich ist alle
Objekte einer Kategorie in einem Durchlauf auszuliefern. Dafür möchte er
von Ihnen, dass Sie einen String generieren mit den folgenden
Eigenschaften: die \(i\)-te Stelle ist eine eins, falls es möglich ist
alle Objekte der Kategorie~\(i\) in einem Durchlauf zu liefern
und~\(0\), falls dies nicht möglich ist. Zur Erinnerung: Der
Weihnachtsmann kann alle Objekte der Kategorie \(i\) in einem Durchlauf
liefern, falls~\(|A|_i \leq B[i]\) gilt. Da der Weihnachtsmann nicht
mehr viel Zeit hat, muss Ihr Algorithmus eine Laufzeit von~\(O(n + m)\)
besitzen.\\

\hfill\break

Input: Zwei Arrays \(A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]\)
mit~~\(1 \leq m, n  \leq 4 \cdot 10^6\)
und~\(\forall 1\leq i  \leq n:  0 \leq a_i,b_i  \leq 10^6\). Außerdem
gilt:~ \(\max(A) \leq |B| - 1\)

Output:~ Ein binärer String~\(s\) der Länge~\(m\) , wobei die \(i\)-te
Stelle folgendermaßen definiert ist:

\(s[i] = \begin{cases} 1, &\text{falls } |A|_i \leq B[i] \\ 0, &\text{falls } |A|_i > B[i] \end{cases}\)\\

wobei~\(|A|_i\) beschreibt wie oft die Zahl~\(i\) in dem Array \(A\)
vorkommt.~

Timelimit: 5 CPU-Sekunden

\textbf{Hinweis:}

(1) Der Substring ""import"", ""eval"",""sort"", ""sol\_calc"", oder ""getattr""
darf nicht in Ihrer Lösung vorkommen.~

(2) Anders als im Cormen definiert beginnen Arrays und Strings der länge
\(n\)~ bei 0 und enden bei ~\(n-1\)~.
","Es ist Weihnachten und dem Weihnachtsmann bleibt wenig Zeit: Er muss
sich ein System ausdenken womit er alle Geschenke rechtzeitig ausliefern
kann. Dafür nutzt er das folgende System: Zuerst werden alle
Kuscheltiere ausgeliefert, dann alle Bücher, usw. Die Kategorie des
$i-$ten Geschenkes ist $A[i]$. Leider hat der Schlit­ten des
Weihnachtsmanns keine unendliche große Kapizität: Für Objekte der
Kategorie $i$ hat der Schlitten von dem Weinhnachtsmann eine maximale
Kapazität von $B[ i]$. Nun möchte er wissen, ob es möglich ist alle
Objekte einer Kategorie in einem Durchlauf auszuliefern. Dafür möchte er
von Ihnen, dass Sie einen String generieren mit den folgenden
Eigenschaften: die $i$-te Stelle ist eine eins, falls es möglich ist
alle Objekte der Kategorie $i$ in einem Durchlauf zu liefern und $0$,
falls dies nicht möglich ist. Zur Erinnerung: Der Weihnachtsmann kann
alle Objekte der Kategorie $i$ in einem Durchlauf liefern,
falls $|A|_i \leq B[i]$ gilt. Da der Weihnachtsmann nicht mehr viel Zeit
hat, muss Ihr Algorithmus eine Laufzeit von $O(n + m)$ besitzen.

Input: Zwei Arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$
mit  $1 \leq m, n  \leq 4 \cdot 10^6$
und $\forall 1\leq i  \leq n:  0 \leq a_i,b_i  \leq 10^6$. Außerdem
gilt:  $\max(A) \leq |B| - 1$

Output:  Ein binärer String $s$ der Länge $m$ , wobei die $i$-te Stelle
folgendermaßen definiert ist:

$s[i] = \begin{cases} 1, &\text{falls } |A|_i \leq B[i] \\ 0, &\text{falls } |A|_i > B[i] \end{cases}$

wobei $|A|_i$ beschreibt wie oft die Zahl $i$ in dem Array $A$
vorkommt. 

Timelimit: 5 CPU-Sekunden

Hinweis:

(1) Der Substring ""import"", ""eval"",""sort"", ""sol_calc"", oder ""getattr""
darf nicht in Ihrer Lösung vorkommen. 

(2) Anders als im Cormen definiert beginnen Arrays und Strings der länge
$n$  bei 0 und enden bei  $n-1$ .
","It's Christmas and Santa Claus has little time left: he must
to come up with a system to deliver all the presents on time.
To do this, he uses the following system: first, all the cuddly
toys are delivered, then all the books, and so on. The category of the
$i-$th gift is $A[i]$. Unfortunately the sleigh of
Santa Claus does not have an infinitely large capacity: For objects of the
category $i$, Santa's sleigh has a maximum capacity of $B[ i]$.
Now he would like to know if it is possible to deliver all the
objects of a category in one run. For this he wants
you to generate a string with the following properties:
the $i$-th digit is a one, if it is possible to deliver
all objects of the category $i$ in one pass and $0$,
if this is not possible. As a reminder, Santa Claus can
deliver all objects of category $i$ in one pass,
if $|A|_i \leq B[i]$ holds. Since Santa does not have much time left
your algorithm must have a runtime of $O(n + m)$.

Input: Two arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$
with $1 \leq m, n \leq 4 \cdot 10^6$
and $\forall 1\leq i \leq n: 0 \leq a_i,b_i \leq 10^6$. Furthermore
it holds: $\max(A) \leq |B| - 1$

Output:  A binary string $s$ of length $m$ , where the $i$-th digit is
is defined as follows:

$s[i] = \begin{cases} 1, &\text{when } |A|_i \leq B[i] \ 0, &\text{when } |A|_i > B[i] \end{cases}$

where $|A|_i$ describes how many times the number $i$ occurs in the array $A$.

Timelimit: 5 CPU seconds

Hint:

(1) The substring ""import"", ""eval"", ""sort"", ""sol_calc"", or ""getattr""
must not appear in your solution. 

(2) Unlike defined in Cormen, arrays and strings of length
$n$ start at 0 and end at $n-1$ .
","def calc(A,B):
    pass","import random as rand

def generate_random(iterations, upper_randb, upper_randa):
    a = []
    b = []
    for i in range(iterations):
        a.append(rand.randrange(upper_randa))
    for i in range(10**6+1):
        b.append(rand.randrange(upper_randb))
    return a,b

def sol_calc(A,B):
    C = []
    for i in range(2 * 10**6 + 2):
        C.append(0)
    for a in A:
        C[a] = C[a] + 1
    sol = """"
    for i in range(len(B)):
        if C[i] <= B[i]:
            sol += ""1""
        else:
            sol += ""0""
    return sol


{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def calc(A, B):
    C = []
    for i in range(10**6 + 1):
        C.append(0)
    for a in A:
        C[a] = C[a] + 1
    sol = """"
    for i in range(len(B)):
        if C[i] <= B[i]:
            sol += ""1""
        else:
            sol += ""0""
    return sol"
"21_22-2-2-python","Warentransport (Python)","Transporting Goods (Python)","In einer großen Lagerhalle ist ein Roboter zuständig für den Transport
von Waren aus dem Lager X zum Lager Y. Der Roboter arbeitete \(n\) Tage.
Am \(i-\)ten (für \(0\leq i\leq n-1\)) Tag bewegte der Roboter \(x_i\)
Waren aus dem ersten Lager zum zweiten Lager. Diese Werte werden in~
einer Liste der Länge \(n\) von nicht negativen Integern:
\(A = [x_0,...,x_{n-1}]\) abgespeichert. Nun wollen wir eine Liste von
Anfragen \(B = [(l_1,r_1),...,(l_n,r_n)]\) bearbeiten.~

Hierfür möchte man wissen wie viele Waren der Roboter zwischen den Tagen
\(l_i\) und \(r_i\) transportiert hat mit
\(0\leq l_i \leq r_i \leq n-1\) für \(1\leq i\leq n\). Hierbei
bildet~\([l_i,r_i]\) ein abgeschlossenes Intervall. Zum Beispiel
für~~\(A = [x_0,x_1] = [4,5]\) und Anfragen
\(B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]\) erhalten
wir~\([\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]\).

Für jede Anfrage soll also eine Liste zurückgeben werden der folgenden
Form:

\([\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]\). Diese Berechnung
soll in \(O(n)\) erfolgen.

\textbf{Der String ""check\_calc"" oder ""eval"" darf nicht in Ihrer Lösung
vorkommen.}

Input: Eine Liste der Länge \(n\) von nicht negativen Integern:
\(A = [x_0,...,x_{n-1}]\) und eine Liste von zweier Tupeln der Länge
\(O(n)\) \(B = [(l_1,r_1),...,(l_n,r_n)]\) mit
\(0\leq l_i \leq r_i \leq n-1\) für \(1\leq i\leq n\)).

\hfill\break

Output: Eine Liste der Länge \(n\) von nicht negativen Integern:

\([\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]\) berechnet in
\(O(n)\).

\textbf{Hierbei darf der~{String ""check\_calc"" oder ""eval""~ nicht in
Ihrer Lösung vorkommen.}}

Hinweis: Sei \(l_j \geq 1\). Dann gilt:~

\(\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k\)~
","In einer großen Lagerhalle ist ein Roboter zuständig für den Transport
von Waren aus dem Lager X zum Lager Y. Der Roboter arbeitete $n$ Tage.
Am $i-$ten (für $0\leq i\leq n-1$) Tag bewegte der Roboter $x_i$ Waren
aus dem ersten Lager zum zweiten Lager. Diese Werte werden in  einer
Liste der Länge $n$ von nicht negativen Integern:
$A = [x_0,...,x_{n-1}]$ abgespeichert. Nun wollen wir eine Liste von
Anfragen $B = [(l_1,r_1),...,(l_n,r_n)]$ bearbeiten. 

Hierfür möchte man wissen wie viele Waren der Roboter zwischen den Tagen
$l_i$ und $r_i$ transportiert hat mit $0\leq l_i \leq r_i \leq n-1$ für
$1\leq i\leq n$. Hierbei bildet $[l_i,r_i]$ ein abgeschlossenes
Intervall. Zum Beispiel für  $A = [x_0,x_1] = [4,5]$ und Anfragen
$B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]$ erhalten
wir $[\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]$.

Für jede Anfrage soll also eine Liste zurückgeben werden der folgenden
Form:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$. Diese Berechnung
soll in $O(n)$ erfolgen.

Der String ""check_calc"" oder ""eval"" darf nicht in Ihrer Lösung
vorkommen.

Input: Eine Liste der Länge $n$ von nicht negativen Integern:
$A = [x_0,...,x_{n-1}]$ und eine Liste von zweier Tupeln der Länge
$O(n)$ $B = [(l_1,r_1),...,(l_n,r_n)]$ mit $0\leq l_i \leq r_i \leq n-1$
für $1\leq i\leq n$).

Output: Eine Liste der Länge $n$ von nicht negativen Integern:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$ berechnet in $O(n)$.

Hierbei darf der String ""check_calc"" oder ""eval""  nicht in Ihrer Lösung
vorkommen.

Hinweis: Sei $l_j \geq 1$. Dann gilt: 

$\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k$ 
","In a large warehouse, one robot is responsible for transporting
goods from warehouse X to warehouse Y. The robot worked $n$ days.
On the $i-$th (for $0\leq i\leq n-1$) day, the robot moved $x_i$ goods
from the first warehouse to the second warehouse. These values are stored in a
list of length $n$ of non-negative integers:
$A = [x_0,...,x_{n-1}]$. Now we want to process a list of
queries $B = [(l_1,r_1),...,(l_n,r_n)]$. 

For this one would like to know how many goods the robot has tranported between the days
$l_i$ and $r_i$ with $0\leq l_i \leq r_i \leq n-1$ for
$1\leq i\leq n$. Here $[l_i,r_i]$ forms a closed
interval. For example, for $A = [x_0,x_1] = [4,5]$ and queries
$B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]$ we get
$[\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]$.

So for each query, we want to return a list of the following
form:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$. This calculation
shall be done in $O(n)$.

The string ""check_calc"" or ""eval"" must not appear in your solution.

Input: a list of length $n$ of non-negative integers:
$A = [x_0,...,x_{n-1}]$ and a list of two-tuples of length
$O(n)$ $B = [(l_1,r_1),...,(l_n,r_n)]$ with $0\leq l_i \leq r_i \leq n-1$
for $1\leq i\leq n$).

Output: A list of length $n$ of non-negative integers:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$ computed in $O(n)$.

Here the string ""check_calc"" or ""eval"" must not appear in your solution

Note: Let $l_j \geq 1$. Then: 

$\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k$ ","def calc(a,b):
    return []","from random import randint

def check_calc(a,b):
    n = len(a)
    c = [0] * n
    d = [0] * n
    c[0] = a[0]
    for i in range(1,n):
        c[i] += a[i] + c[i-1]
    for i in range(n):
        if b[i][0] - 1 >= 0:
            d[i] = c[b[i][1]]- c[b[i][0] - 1]
        else:
            d[i] = c[b[i][1]]
    return d
    

{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

        
{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def calc(a,b):
    n = len(a)
    c = [0] * n
    d = [0] * n
    c[0] = a[0]
    for i in range(1,n):
        c[i] += a[i] + c[i-1]
    for i in range(n):
        if b[i][0] - 1 >= 0:
            d[i] = c[b[i][1]]- c[b[i][0] - 1]
        else:
            d[i] = c[b[i][1]]
    return d"
"21_22-2-1-java","Logistik am Nordpol (Java)","Logistics at the North Pole (Java)","Es ist Weihnachten und dem Weihnachtsmann bleibt wenig Zeit: Er muss
sich ein System ausdenken womit er alle Geschenke rechtzeitig ausliefern
kann. Dafür nutzt er das folgende System: Zuerst werden alle
Kuscheltiere ausgeliefert, dann alle Bücher, usw. Die Kategorie des
\(i-\)ten Geschenkes ist~\(A[i]\). Leider hat der~Schlit­ten des
Weihnachtsmanns keine unendliche große Kapizität: Für Objekte der
Kategorie~\(i\) hat der Schlitten von dem Weinhnachtsmann eine maximale
Kapazität von~\(B[ i]\). Nun möchte er wissen, ob es möglich ist alle
Objekte einer Kategorie in einem Durchlauf auszuliefern. Dafür möchte er
von Ihnen, dass Sie einen String generieren mit den folgenden
Eigenschaften: die \(i\)-te Stelle ist eine eins, falls es möglich ist
alle Objekte der Kategorie~\(i\) in einem Durchlauf zu liefern
und~\(0\), falls dies nicht möglich ist. Zur Erinnerung: Der
Weihnachtsmann kann alle Objekte der Kategorie \(i\) in einem Durchlauf
liefern, falls~\(|A|_i \leq B[i]\) gilt. Da der Weihnachtsmann nicht
mehr viel Zeit hat, muss Ihr Algorithmus eine Laufzeit von~\(O(n + m)\)
besitzen.\\

\hfill\break

Input: Zwei Arrays \(A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]\)
mit~~\(1 \leq m, n  \leq 2,85 \cdot 10^7\)
und~\(\forall 1\leq i  \leq n:  0 \leq a_i,b_i  \leq 2,85 \cdot 10^7\).
Außerdem gilt:~ \(\max(A) \leq |B| - 1\)

Output:~ Ein binärer String~\(s\) der Länge~\(m\) , wobei die \(i\)-te
Stelle folgendermaßen definiert ist:

\(s[i] = \begin{cases} 1, &\text{falls } |A|_i \leq B[i] \\ 0, &\text{falls } |A|_i > B[i] \end{cases}\)\\

wobei~\(|A|_i\) beschreibt wie oft die Zahl~\(i\) in dem Array \(A\)
vorkommt.

Timelimit: 1 CPU-Sekunde\\

\hfill\break

\textbf{Hinweis:}

(1) Der Substring ""sort"", ""reflect"", ""sol\_calc"", oder ""import"" darf
nicht in Ihrer Lösung vorkommen.~

(2) Anders als im Cormen definiert beginnen Arrays und Strings der länge
\(n\)~ bei 0 und enden bei ~\(n-1\)~

(3) Nutzen Sie die ""StringBuilder"" Klasse um Ihre Lösung zu generieren.
Nutzen Sie \textbf{nicht} die Java ""String"" Klasse, falls Sie ihre
Lösung inkrementell aufbauen, da die Strings bei jedem Aufruf neu
generiert werden müssen.

\hfill\break
","Es ist Weihnachten und dem Weihnachtsmann bleibt wenig Zeit: Er muss
sich ein System ausdenken womit er alle Geschenke rechtzeitig ausliefern
kann. Dafür nutzt er das folgende System: Zuerst werden alle
Kuscheltiere ausgeliefert, dann alle Bücher, usw. Die Kategorie des
$i-$ten Geschenkes ist $A[i]$. Leider hat der Schlit­ten des
Weihnachtsmanns keine unendliche große Kapizität: Für Objekte der
Kategorie $i$ hat der Schlitten von dem Weinhnachtsmann eine maximale
Kapazität von $B[ i]$. Nun möchte er wissen, ob es möglich ist alle
Objekte einer Kategorie in einem Durchlauf auszuliefern. Dafür möchte er
von Ihnen, dass Sie einen String generieren mit den folgenden
Eigenschaften: die $i$-te Stelle ist eine eins, falls es möglich ist
alle Objekte der Kategorie $i$ in einem Durchlauf zu liefern und $0$,
falls dies nicht möglich ist. Zur Erinnerung: Der Weihnachtsmann kann
alle Objekte der Kategorie $i$ in einem Durchlauf liefern,
falls $|A|_i \leq B[i]$ gilt. Da der Weihnachtsmann nicht mehr viel Zeit
hat, muss Ihr Algorithmus eine Laufzeit von $O(n + m)$ besitzen.

Input: Zwei Arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$
mit  $1 \leq m, n  \leq 2,85 \cdot 10^7$
und $\forall 1\leq i  \leq n:  0 \leq a_i,b_i  \leq 2,85 \cdot 10^7$.
Außerdem gilt:  $\max(A) \leq |B| - 1$

Output:  Ein binärer String $s$ der Länge $m$ , wobei die $i$-te Stelle
folgendermaßen definiert ist:

$s[i] = \begin{cases} 1, &\text{falls } |A|_i \leq B[i] \\ 0, &\text{falls } |A|_i > B[i] \end{cases}$

wobei $|A|_i$ beschreibt wie oft die Zahl $i$ in dem Array $A$ vorkommt.

Timelimit: 1 CPU-Sekunde

Hinweis:

(1) Der Substring ""sort"", ""reflect"", ""sol_calc"", oder ""import"" darf
nicht in Ihrer Lösung vorkommen. 

(2) Anders als im Cormen definiert beginnen Arrays und Strings der länge
$n$  bei 0 und enden bei  $n-1$ 

(3) Nutzen Sie die ""StringBuilder"" Klasse um Ihre Lösung zu generieren.
Nutzen Sie nicht die Java ""String"" Klasse, falls Sie ihre Lösung
inkrementell aufbauen, da die Strings bei jedem Aufruf neu generiert
werden müssen.
","It's Christmas and Santa Claus has little time left: he must
to come up with a system to deliver all the presents on time.
To do this, he uses the following system: first, all the cuddly
toys are delivered, then all the books, and so on. The category of the
$i-$th gift is $A[i]$. Unfortunately the sleigh of
Santa Claus does not have an infinitely large capacity: For objects of the
category $i$, Santa's sleigh has a maximum capacity of $B[ i]$.
Now he would like to know if it is possible to deliver all the
objects of a category in one run. For this he wants
you to generate a string with the following properties:
the $i$-th digit is a one, if it is possible to deliver
all objects of the category $i$ in one pass and $0$,
if this is not possible. As a reminder, Santa Claus can
deliver all objects of category $i$ in one pass,
if $|A|_i \leq B[i]$ holds. Since Santa does not have much time left
your algorithm must have a runtime of $O(n + m)$.

Input: Two arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$
with $1 \leq m, n \leq 2.85 \cdot 10^7$
and $\forall 1\leq i \leq n: 0 \leq a_i,b_i \leq 2,85 \cdot 10^7$.
Moreover, $\max(A) \leq |B| - 1$

Output:  A binary string $s$ of length $m$ , where the $i$-th digit is
is defined as follows:

$s[i] = \begin{cases} 1, &\text{when } |A|_i \leq B[i] \ 0, &\text{when } |A|_i > B[i] \end{cases}$

where $|A|_i$ describes how many times the number $i$ occurs in the array $A$.

Timelimit: 1 CPU seconds

Hint:

(1) The substring ""sort"", ""reflect"", ""sol_calc"", or ""import"" must 
not occur in your solution. 

(2) Unlike defined in Cormen, arrays and strings of length
$n$ start at 0 and end at $n-1$. 

(3) Use the ""StringBuilder"" class to generate your solution.
Do not use the Java ""String"" class if you are building your solution
incrementally, because the strings have to be newly generated with each call.","String calc(int A[], int B[]){
    return null;
}","import java.util.Arrays; 
import java.util.concurrent.ThreadLocalRandom;

public class __tester__ {
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}
    public String studentAnswer = ""{{ STUDENT_ANSWER | replace({'\r': '', '\n': ''}) | e('java') }}"";
    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }
    public static String sol_calc(int A[], int B[]){
    int []C = new int[B.length+1];
    for(int i=0;i<A.length;i++)
        C[A[i]]++;
    StringBuilder sol = new StringBuilder();
    for(int i=0;i<B.length;i++)
    {
        if(C[i] > B[i])
            sol.append('0');
        else
            sol.append('1');
    }
    return sol.toString();
}



    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","String calc(int A[], int B[]){
    int []C = new int[B.length+1];
    for(int i=0;i<A.length;i++)
        C[A[i]]++;
    StringBuilder sol = new StringBuilder();
    for(int i=0;i<B.length;i++)
    {
        if(C[i] > B[i])
            sol.append('0');
        else
            sol.append('1');
    }
    return sol.toString();
}"
"21_22-2-2-java","Warentransport (Java)","Transporting Goods (Java)","In einer großen Lagerhalle ist ein Roboter zuständig für den Transport
von Waren aus dem Lager X zum Lager Y. Der Roboter arbeitete \(n\) Tage.
Am \(i-\)ten (für \(0\leq i\leq n-1\)) Tag bewegte der Roboter \(x_i\)
Waren aus dem ersten Lager zum zweiten Lager. Diese Werte werden in~
einer Liste der Länge \(n\) von nicht negativen Integern:
\(A = [x_0,...,x_{n-1}]\) abgespeichert. Nun wollen wir eine Liste von
Anfragen \(B = [(l_1,r_1),...,(l_n,r_n)]\) bearbeiten.~

Hierfür möchte man wissen wie viele Waren der Roboter zwischen den Tagen
\(l_i\) und \(r_i\) transportiert hat mit
\(0\leq l_i \leq r_i \leq n-1\) für \(1\leq i\leq n\). Hierbei
bildet~\([l_i,r_i]\) ein \textbf{abgeschlossenes} Intervall. Zum
Beispiel für~~\(A = [x_0,x_1] = [4,5]\) und Anfragen
\(B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]\) erhalten
wir~\([\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]\).

Für jede Anfrage soll also eine Liste zurückgeben werden der folgenden
Form:

\([\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]\). Diese Berechnung
soll in \(O(n)\) erfolgen.

\hfill\break

Input: Eine Liste der Länge \(n\) von nicht negativen Integern:
\(A = [x_0,...,x_{n-1}]\) und eine Liste von zweier Tupeln der Länge
\(O(n)\) \(B = [(l_1,r_1),...,(l_n,r_n)]\) mit
\(0\leq l_i \leq r_i \leq n-1\) für \(1\leq i\leq n\)).

\hfill\break

Output: Eine Liste der Länge \(n\) von nicht negativen Integern:

\([\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]\) berechnet in
\(O(n)\).

Hinweis: Sei \(l_j \geq 1\). Dann gilt:~

\(\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k\)~
","In einer großen Lagerhalle ist ein Roboter zuständig für den Transport
von Waren aus dem Lager X zum Lager Y. Der Roboter arbeitete $n$ Tage.
Am $i-$ten (für $0\leq i\leq n-1$) Tag bewegte der Roboter $x_i$ Waren
aus dem ersten Lager zum zweiten Lager. Diese Werte werden in  einer
Liste der Länge $n$ von nicht negativen Integern:
$A = [x_0,...,x_{n-1}]$ abgespeichert. Nun wollen wir eine Liste von
Anfragen $B = [(l_1,r_1),...,(l_n,r_n)]$ bearbeiten. 

Hierfür möchte man wissen wie viele Waren der Roboter zwischen den Tagen
$l_i$ und $r_i$ transportiert hat mit $0\leq l_i \leq r_i \leq n-1$ für
$1\leq i\leq n$. Hierbei bildet $[l_i,r_i]$ ein abgeschlossenes
Intervall. Zum Beispiel für  $A = [x_0,x_1] = [4,5]$ und Anfragen
$B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]$ erhalten
wir $[\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]$.

Für jede Anfrage soll also eine Liste zurückgeben werden der folgenden
Form:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$. Diese Berechnung
soll in $O(n)$ erfolgen.

Input: Eine Liste der Länge $n$ von nicht negativen Integern:
$A = [x_0,...,x_{n-1}]$ und eine Liste von zweier Tupeln der Länge
$O(n)$ $B = [(l_1,r_1),...,(l_n,r_n)]$ mit $0\leq l_i \leq r_i \leq n-1$
für $1\leq i\leq n$).

Output: Eine Liste der Länge $n$ von nicht negativen Integern:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$ berechnet in $O(n)$.

Hinweis: Sei $l_j \geq 1$. Dann gilt: 

$\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k$ 
","In a large warehouse, one robot is responsible for transporting
goods from warehouse X to warehouse Y. The robot worked $n$ days.
On the $i-$th (for $0\leq i\leq n-1$) day, the robot moved $x_i$ goods
from the first warehouse to the second warehouse. These values are stored in a
list of length $n$ of non-negative integers:
$A = [x_0,...,x_{n-1}]$. Now we want to process a list of
queries $B = [(l_1,r_1),...,(l_n,r_n)]$. 

For this one would like to know how many goods the robot has tranported between the days
$l_i$ and $r_i$ with $0\leq l_i \leq r_i \leq n-1$ for
$1\leq i\leq n$. Here $[l_i,r_i]$ forms a closed
interval. For example, for $A = [x_0,x_1] = [4,5]$ and queries
$B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]$ we get
$[\sum_{i=l_1}^{r_1}x_i,\sum_{i=l_2}^{r_2}x_i] = [\sum_{i=1}^{1}x_i,\sum_{i=0}^{1}x_i] = [5, 4 + 5]$.

So for each query, we want to return a list of the following
form:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$. This calculation
shall be done in $O(n)$.

Input: a list of length $n$ of non-negative integers:
$A = [x_0,...,x_{n-1}]$ and a list of two-tuples of length
$O(n)$ $B = [(l_1,r_1),...,(l_n,r_n)]$ with $0\leq l_i \leq r_i \leq n-1$
for $1\leq i\leq n$).

Output: A list of length $n$ of non-negative integers:

$[\sum_{i=l_1}^{r_1}x_i,...,\sum_{i=l_n}^{r_n}x_i]$ computed in $O(n)$.

Note: Let $l_j \geq 1$. Then: 

$\sum_{i=l_j}^{r_j}x_i= \sum_{k=0}^{r_j}x_k - \sum_{k=0}^{l_j - 1}x_k$ ","int [] calc(int []a, int[][]b){
    
    int n = a.length;
    int [] d = new int[n];
   
   
   
    return d;   
}","import java.util.Arrays;



public class __tester__ {
    
    public static int [] check_calc(int []a, int[][]b){
    
    int n = a.length;
    int [] c = new int[n];
    int [] d = new int[n];
    
    c[0] = a[0];
    for (int i = 1; i < n ; i++){
        c[i] = a[i] + c[i-1];
    }
    for (int i = 0; i < n ; i++){
        if (b[i][0]-1 >= 0){
            d[i] = c[b[i][1]] - c[b[i][0] - 1];
        }else{
            d[i] = c[b[i][1]];
        }
    }
    return d;   
}
    
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}

    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }

    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","int [] calc(int []a, int[][]b){
    
    int n = a.length;
    int [] c = new int[n];
    int [] d = new int[n];
    
    c[0] = a[0];
    for (int i = 1; i < n ; i++){
        c[i] = a[i] + c[i-1];
    }
    for (int i = 0; i < n ; i++){
        if (b[i][0]-1 >= 0){
            d[i] = c[b[i][1]] - c[b[i][0] - 1];
        }else{
            d[i] = c[b[i][1]];
        }
    }
    return d;   
}"
"21_22-3-1-python","Werbetafel (Python)","Billboard (Python)","(Diese Aufgabe ist eine leicht abgeänderte alte Klausuraufgabe aus dem
WS 2020/21)

Ein Unternehmen erhält die Genehmigung, eine Landstraße auf einer
Straßenseite mit Werbetafeln zu versehen. Entlang der
\(n \in \mathbb{N}\) Kilometer langen Landstraße gibt es im Abstand von
je genau einem Kilometer \(n+1\) geeignete Standorte. Für den Standort
bei Kilometer \(i \in\{0,1, \ldots, n\}\) sind Werbekunden bereit, einen
Betrag \(w_i\) mit \(0 < w_{i} < 10^9\) an das Unternehmen zu zahlen.
Allerdings besagt die Straßenverkehrsordnung, dass zwischen je zwei
Werbetafeln mindestens zwei Kilometer Abstand bestehen müssen. Errichtet
das Unternehmen also bei Kilometer \(i\) eine Werbetafel, so darf bei
Kilometer \(i-1\) und \(i+1\) keine Werbetafel errichtet werden.

Helfen Sie dem Unternehmen eine Auswahl an Standorten zu bestimmen, die
den Gesamtgewinn aus der Vermietung der Standorte maximiert.

Input: Ein Array \(W\) der Größe~\(n+1\) für ein
\(n \in \mathbb{N} \land 1  \leq n \leq 1000\).

Output: Der maximimale Gewinn, den man mit den Werbetafeln erzielen
kann.

Der Output muss in~\(O(n)\) berechnet werden.
","(Diese Aufgabe ist eine leicht abgeänderte alte Klausuraufgabe aus dem
WS 2020/21)

Ein Unternehmen erhält die Genehmigung, eine Landstraße auf einer
Straßenseite mit Werbetafeln zu versehen. Entlang der $n \in \mathbb{N}$
Kilometer langen Landstraße gibt es im Abstand von je genau einem
Kilometer $n+1$ geeignete Standorte. Für den Standort bei Kilometer
$i \in\{0,1, \ldots, n\}$ sind Werbekunden bereit, einen Betrag $w_i$
mit $0 < w_{i} < 10^9$ an das Unternehmen zu zahlen. Allerdings besagt
die Straßenverkehrsordnung, dass zwischen je zwei Werbetafeln mindestens
zwei Kilometer Abstand bestehen müssen. Errichtet das Unternehmen also
bei Kilometer $i$ eine Werbetafel, so darf bei Kilometer $i-1$ und $i+1$
keine Werbetafel errichtet werden.

Helfen Sie dem Unternehmen eine Auswahl an Standorten zu bestimmen, die
den Gesamtgewinn aus der Vermietung der Standorte maximiert.

Input: Ein Array $W$ der Größe $n+1$ für ein
$n \in \mathbb{N} \land 1  \leq n \leq 1000$.

Output: Der maximimale Gewinn, den man mit den Werbetafeln erzielen
kann.

Der Output muss in $O(n)$ berechnet werden.
","(This task is a slightly modified old exam task from the
WS 2020/21)

A company obtains permission to place billboards on one side of a road.
Along the $n \in \mathbb{N}$ kilometers long road, there are $n+1$ suitable
locations at intervals of exactly one kilometer. For the location at kilometer
$i \in\{0,1, \ldots, n\}$ advertisers are willing to pay an amount $w_i$
with $0 < w_{i} < 10^9$ to the company. However, the road traffic regulation states
that there must be at least two kilometers between every two billboards.
So if the company places a billboard at kilometer $i$, then at kilometer $i-1$ and $i+1$
no billboard may be placed.

Help the company determine a selection of locations that will
maximizes the total profit from renting the sites.

Input: an array $W$ of size $n+1$ for a
$n \in \mathbb{N} \land 1 \leq n \leq 1000$.

Output: The maximum profit that can be obtained from the billboards.

The output must be calculated in $O(n)$.
","def opt(W):
    pass","import random as rand
def opti(W):
    n = len(W) - 1
    memo = [-1] * (n + 1)
    return opti_helper(n, W, memo)


def opti_helper(n, W, memo):
    if n == 0:
        return W[0]
    if n == 1:
        return max(W[0], W[1])
    if memo[n] != -1:
        return memo[n]
    else:
        memo[n] = max(W[n] + opti_helper(n - 2, W, memo), opti_helper(n - 1, W, memo))
        return memo[n]
        
{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def opt(W):
    n = len(W) - 1
    memo = [-1] * (n + 1)
    return opt_helper(n, W, memo)


def opt_helper(n, W, memo):
    if n == 0:
        return W[0]
    if n == 1:
        return max(W[0], W[1])
    if memo[n] != -1:
        return memo[n]
    else:
        memo[n] = max(W[n] + opt_helper(n - 2, W, memo), opt_helper(n - 1, W, memo))
        return memo[n]"
"21_22-3-2-python","Längester Pfad im DAG (Python)","Longest path DAG (Python)","Ziel dieser Aufgabe ist es den längsten Pfad im dag (directed acyclic
graph)~ in~\(O(N+M)\) zu finden.~

Input: Eine natürliche Zahl \(1 \leq N \leq 2500\), die angibt, wie
viele Knoten der Graph \(G\) hat. Ein zwei dimensionales
Array~\(A\){~}~der Größe~\(1 \leq M \leq 10^6\){~}~{von ganzen Zahlen
\(A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]\),}{~
was die Knoten- und Kantenmenge von~\(G\) codiert.~
Falls~~\([a,b] \in A\), dann gibt es eine gerichtete Kante von dem
Knoten\(a\) zum Knoten \(b\). Sie dürfen annehmen, dass es keine
gerichteten Zyklen in \(G\) gibt. Ein Beispiel: Sei~\(N = 3\) und~ die
Kanten \(A = [[1,2],[2,3]]\) dann entsteht der folgende Graph:}{}

\includegraphics[width=3.22917in,height=0.69792in]{@@PLUGINFILE@@/simple directed graph.png}\\

Output: Die Länge des längsten gerichteten Pfades in \(G\). Hierbei muss
Ihr Algorithmus die Lösung in~\(O(N+M)\) berechnen.\\

Zeitbegrenzung: 4 CPU-Sekunden (\(O(N+M)\) ).

\textbf{Hinweis:}

(1) Der Substring ""import"", ""eval"", ""sol\_calc"", oder ""getattr"" darf
nicht in Ihrer Lösung vorkommen.~

(2) Falls Sie Schwierigkeiten bei dieser Aufgabe haben: Ignorieren Sie
die Laufzeiteinschränkungen und implementieren Sie zuerst eine naive
rekursive Lösung. Verwenden Sie dann dynamische Programmierung
(Memoisierung) um die gewünschte Laufzeit zu erreichen.

(3) Einige Test-Cases wurden verborgen und werden nicht angezeigt um
Hardcoding der Lösungen zu verhindern.\\
\strut \\
(4) Falls Sie Schwierigkeiten mit der Aufgabe haben, lesen Sie folgende
Seiten vom Cormen (Introduction to algorithms third edition)~ pp.
384-389 (ab dem Unterpunkt ""overlapping subproblems"") oder/und
\url{https://en.wikipedia.org/wiki/Overlapping_subproblems}.\\
","Ziel dieser Aufgabe ist es den längsten Pfad im dag (directed acyclic
graph)  in $O(N+M)$ zu finden. 

Input: Eine natürliche Zahl $1 \leq N \leq 2500$, die angibt, wie viele
Knoten der Graph $G$ hat. Ein zwei dimensionales Array $A$  der
Größe $1 \leq M \leq 10^6$  von ganzen Zahlen
$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$,  was
die Knoten- und Kantenmenge von $G$ codiert.  Falls  $[a,b] \in A$, dann
gibt es eine gerichtete Kante von dem Knoten$a$ zum Knoten $b$. Sie
dürfen annehmen, dass es keine gerichteten Zyklen in $G$ gibt. Ein
Beispiel: Sei $N = 3$ und  die Kanten $A = [[1,2],[2,3]]$ dann entsteht
der folgende Graph:

[]

Output: Die Länge des längsten gerichteten Pfades in $G$. Hierbei muss
Ihr Algorithmus die Lösung in $O(N+M)$ berechnen.

Zeitbegrenzung: 4 CPU-Sekunden ($O(N+M)$ ).

Hinweis:

(1) Der Substring ""import"", ""eval"", ""sol_calc"", oder ""getattr"" darf
nicht in Ihrer Lösung vorkommen. 

(2) Falls Sie Schwierigkeiten bei dieser Aufgabe haben: Ignorieren Sie
die Laufzeiteinschränkungen und implementieren Sie zuerst eine naive
rekursive Lösung. Verwenden Sie dann dynamische Programmierung
(Memoisierung) um die gewünschte Laufzeit zu erreichen.

(3) Einige Test-Cases wurden verborgen und werden nicht angezeigt um
Hardcoding der Lösungen zu verhindern.
(4) Falls Sie Schwierigkeiten mit der Aufgabe haben, lesen Sie folgende
Seiten vom Cormen (Introduction to algorithms third edition)  pp.
384-389 (ab dem Unterpunkt ""overlapping subproblems"") oder/und
https://en.wikipedia.org/wiki/Overlapping_subproblems.
","The goal of this task is to find the longest path in the dag (directed acyclic
graph) in $O(N+M)$. 

Input: A natural number $1 \leq N \leq 2500$, which indicates how many
nodes the graph $G$ has. A two dimensional array $A$ of the
size $1 \leq M \leq 10^6$ of integers
$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$, which
encodes the node and edge set of $G$.  If $[a,b] \in A$, then
there is a directed edge from the node$a$ to the node $b$. You
may assume that there are no directed cycles in $G$. An
example: let $N = 3$ and the edges $A = [[1,2],[2,3]]$ then the result is
the following graph:

[]

Output: The length of the longest directed path in $G$.
Your algorithm must compute the solution in $O(N+M)$.

Time limit: 4 CPU seconds ($O(N+M)$ ).

Hint:

(1) The substring ""import"", ""eval"", ""sol_calc"", or ""getattr"" must not
appear in your solution. 

(2) If you have difficulties with this task: Ignore
the runtime restrictions and first implement a naive 
recursive solution. Then use dynamic programming
(memoization) to achieve the desired runtime.

(3) Some test cases have been hidden and are not displayed to 
prevent hardcoding of the solutions.
(4) If you have difficulties with the task, read the following
pages from Cormen (Introduction to algorithms third edition) pp.
384-389 (from the subitem ""overlapping subproblems"") and/or
https://en.wikipedia.org/wiki/Overlapping_subproblems.","def calc(N,A):
    pass","{{ STUDENT_ANSWER }}

__student_answer__ = """"""{{ STUDENT_ANSWER | e('py') }}""""""

SEPARATOR = ""#<ab@17943918#@>#""

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
print(SEPARATOR)
{% endif %}
{% endfor %}","def dfs(node, graph, memo):
    if len(graph[node]) == 0:
        return 0
    elif memo[node] != -1:
        return memo[node]
    else:
        sol = 0
        for child in graph[node]:
            sol = max(sol, dfs(child, graph, memo) + 1)
        memo[node] = sol
        return memo[node]


def calc(N, A):
    graph = [[] for _ in range(N + 1)]
    memo = [-1] * (N + 1)
    graph[0] = [x for x in range(1, N + 1)]
    for edge in A:
        start, end = edge
        graph[start].append(end)
    return dfs(0, graph, memo) - 1"
"21_22-3-1-java","Werbetafel (Java)","Billboard (Java)","(Diese Aufgabe ist eine leicht abgeänderte alte Klausuraufgabe aus dem
WS 2020/21)

Ein Unternehmen erhält die Genehmigung, eine Landstraße auf einer
Straßenseite mit Werbetafeln zu versehen. Entlang der
\(n \in \mathbb{N}\) Kilometer langen Landstraße gibt es im Abstand von
je genau einem Kilometer \(n+1\) geeignete Standorte. Für den Standort
bei Kilometer \(i \in\{0,1, \ldots, n\}\) sind Werbekunden bereit, einen
Betrag \(w_i\) mit \(0 < w_{i} < 10^9\) an das Unternehmen zu zahlen.
Allerdings besagt die Straßenverkehrsordnung, dass zwischen je zwei
Werbetafeln mindestens zwei Kilometer Abstand bestehen müssen. Errichtet
das Unternehmen also bei Kilometer \(i\) eine Werbetafel, so darf bei
Kilometer \(i-1\) und \(i+1\) keine Werbetafel errichtet werden.

Helfen Sie dem Unternehmen eine Auswahl an Standorten zu bestimmen, die
den Gesamtgewinn aus der Vermietung der Standorte maximiert.

Input: Ein Array \(W\) der Größe~\(n+1\) für ein
\(n \in \mathbb{N} \land 1 \leq n \leq 1000\).

Output: Der maximimale Gewinn, den man mit den Werbetafeln erzielen
kann.

Der Output muss in~\(O(n)\) berechnet werden.
","(Diese Aufgabe ist eine leicht abgeänderte alte Klausuraufgabe aus dem
WS 2020/21)

Ein Unternehmen erhält die Genehmigung, eine Landstraße auf einer
Straßenseite mit Werbetafeln zu versehen. Entlang der $n \in \mathbb{N}$
Kilometer langen Landstraße gibt es im Abstand von je genau einem
Kilometer $n+1$ geeignete Standorte. Für den Standort bei Kilometer
$i \in\{0,1, \ldots, n\}$ sind Werbekunden bereit, einen Betrag $w_i$
mit $0 < w_{i} < 10^9$ an das Unternehmen zu zahlen. Allerdings besagt
die Straßenverkehrsordnung, dass zwischen je zwei Werbetafeln mindestens
zwei Kilometer Abstand bestehen müssen. Errichtet das Unternehmen also
bei Kilometer $i$ eine Werbetafel, so darf bei Kilometer $i-1$ und $i+1$
keine Werbetafel errichtet werden.

Helfen Sie dem Unternehmen eine Auswahl an Standorten zu bestimmen, die
den Gesamtgewinn aus der Vermietung der Standorte maximiert.

Input: Ein Array $W$ der Größe $n+1$ für ein
$n \in \mathbb{N} \land 1 \leq n \leq 1000$.

Output: Der maximimale Gewinn, den man mit den Werbetafeln erzielen
kann.

Der Output muss in $O(n)$ berechnet werden.
","(This task is a slightly modified old exam task from the
WS 2020/21)

A company obtains permission to place billboards on one side of a road.
Along the $n \in \mathbb{N}$ kilometers long road, there are $n+1$ suitable
locations at intervals of exactly one kilometer. For the location at kilometer
$i \in\{0,1, \ldots, n\}$ advertisers are willing to pay an amount $w_i$
with $0 < w_{i} < 10^9$ to the company. However, the road traffic regulation states
that there must be at least two kilometers between every two billboards.
So if the company places a billboard at kilometer $i$, then at kilometer $i-1$ and $i+1$
no billboard may be placed.

Help the company determine a selection of locations that will
maximizes the total profit from renting the sites.

Input: an array $W$ of size $n+1$ for a
$n \in \mathbb{N} \land 1 \leq n \leq 1000$.

Output: The maximum profit that can be obtained from the billboards.

The output must be calculated in $O(n)$. ","long opt(long []W){
    
}","public class __tester__ {
    
    public static long opti(long []W){
        int n = W.length - 1;
        long []memo = new long [n+1];
        for (int i = 0; i < n+1; i++)
           memo[i] = -1;
         return opti_helper(n,W,memo);
    }


    public static long opti_helper(int n,long [] W,long [] memo){
        if (n == 0)
            return W[0];
        if (n == 1)
            return Math.max(W[0], W[1]);
        if (memo[n] != -1)
            return memo[n];
        memo[n] = Math.max(W[n] + opti_helper(n - 2, W, memo), opti_helper(n - 1, W, memo));
        return memo[n];
    }
    
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}

    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }

    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","long opt(long []W){
    int n = W.length - 1;
    long []memo = new long [n+1];
    for (int i = 0; i < n+1; i++)
        memo[i] = -1;
    return opt_helper(n,W,memo);
}


long opt_helper(int n,long [] W,long [] memo){
    if (n == 0)
        return W[0];
    if (n == 1)
        return Math.max(W[0], W[1]);
    if (memo[n] != -1)
        return memo[n];
    memo[n] = Math.max(W[n] + opt_helper(n - 2, W, memo), opt_helper(n - 1, W, memo));
    return memo[n];
}"
"21_22-3-2-java","Längester Pfad im DAG (Java)","Longest path DAG (Java)","Ziel dieser Aufgabe ist es den längsten Pfad im dag (directed acyclic
graph)~ in~\(O(N+M)\) zu finden.~

Input: Eine natürliche Zahl \(1 \leq N \leq 2500\), die angibt, wie
viele Knoten der Graph \(G\) hat. Ein zwei dimensionales
Array~\(A\){~}~der Größe~\(1 \leq M \leq 10^6\){~}~{von ganzen Zahlen
\(A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]\),}{~
was die Knoten- und Kantenmenge von~\(G\) codiert.~
Falls~~\([a,b] \in A\), dann gibt es eine gerichtete Kante von dem
Knoten\(a\) zum Knoten \(b\). Sie dürfen annehmen, dass es keine
gerichteten Zyklen in \(G\) gibt. Ein Beispiel: Sei~\(N = 3\) und~ die
Kanten \(A = [[1,2],[2,3]]\) dann entsteht der folgende Graph:}{}

\includegraphics[width=3.22917in,height=0.69792in]{@@PLUGINFILE@@/simple directed graph.png}\\

Output: Die Länge des längsten gerichteten Pfades in \(G\). Hierbei muss
Ihr Algorithmus die Lösung in~\(O(N+M)\) berechnen.

\hfill\break

Zeitbegrenzung: 1 CPU-Sekunde (\(O(N+M)\) ).

\textbf{Hinweis:}

(1) Die Libraries~
java.util.Arrays,~{java.util.ArrayList,~}{java.lang.Math werden schon
automatisch importiert.}

(2) Falls Sie Schwierigkeiten bei dieser Aufgabe haben: Ignorieren Sie
die Laufzeiteinschränkungen und implementieren Sie zuerst eine naive
rekursive Lösung. Verwenden Sie dann dynamische Programmierung
(Memoisierung) um die gewünschte Laufzeit zu erreichen.

(3) Einige Test-Cases wurden verborgen und werden nicht angezeigt um
Hardcoding der Lösungen zu verhindern.\\
\strut \\
(4) Falls Sie Schwierigkeiten mit der Aufgabe haben, lesen Sie folgende
Seiten vom Cormen (Introduction to algorithms third edition)~ pp.
384-389 (ab dem Unterpunkt ""overlapping subproblems"")
oder/und~\url{https://en.wikipedia.org/wiki/Overlapping_subproblems}.\\
","Ziel dieser Aufgabe ist es den längsten Pfad im dag (directed acyclic
graph)  in $O(N+M)$ zu finden. 

Input: Eine natürliche Zahl $1 \leq N \leq 2500$, die angibt, wie viele
Knoten der Graph $G$ hat. Ein zwei dimensionales Array $A$  der
Größe $1 \leq M \leq 10^6$  von ganzen Zahlen
$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$,  was
die Knoten- und Kantenmenge von $G$ codiert.  Falls  $[a,b] \in A$, dann
gibt es eine gerichtete Kante von dem Knoten$a$ zum Knoten $b$. Sie
dürfen annehmen, dass es keine gerichteten Zyklen in $G$ gibt. Ein
Beispiel: Sei $N = 3$ und  die Kanten $A = [[1,2],[2,3]]$ dann entsteht
der folgende Graph:

[]

Output: Die Länge des längsten gerichteten Pfades in $G$. Hierbei muss
Ihr Algorithmus die Lösung in $O(N+M)$ berechnen.

Zeitbegrenzung: 1 CPU-Sekunde ($O(N+M)$ ).

Hinweis:

(1) Die Libraries  java.util.Arrays, java.util.ArrayList, java.lang.Math
werden schon automatisch importiert.

(2) Falls Sie Schwierigkeiten bei dieser Aufgabe haben: Ignorieren Sie
die Laufzeiteinschränkungen und implementieren Sie zuerst eine naive
rekursive Lösung. Verwenden Sie dann dynamische Programmierung
(Memoisierung) um die gewünschte Laufzeit zu erreichen.

(3) Einige Test-Cases wurden verborgen und werden nicht angezeigt um
Hardcoding der Lösungen zu verhindern.
(4) Falls Sie Schwierigkeiten mit der Aufgabe haben, lesen Sie folgende
Seiten vom Cormen (Introduction to algorithms third edition)  pp.
384-389 (ab dem Unterpunkt ""overlapping subproblems"")
oder/und https://en.wikipedia.org/wiki/Overlapping_subproblems.
","The goal of this task is to find the longest path in the dag (directed acyclic
graph) in $O(N+M)$. 

Input: A natural number $1 \leq N \leq 2500$, which indicates how many
nodes the graph $G$ has. A two dimensional array $A$ of the
size $1 \leq M \leq 10^6$ of integers
$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$, which
encodes the node and edge set of $G$.  If $[a,b] \in A$, then
there is a directed edge from the node$a$ to the node $b$. You
may assume that there are no directed cycles in $G$. An
example: let $N = 3$ and the edges $A = [[1,2],[2,3]]$ then the result is
the following graph:

[]

Output: The length of the longest directed path in $G$.
Your algorithm must compute the solution in $O(N+M)$.

Time limit: 1 CPU second ($O(N+M)$ ).

Hint:

(1) The libraries java.util.Arrays, java.util.ArrayList, java.lang.Math
are already imported automatically.

(2) If you have difficulties with this task: Ignore
the runtime restrictions and first implement a naive 
recursive solution. Then use dynamic programming
(memoization) to achieve the desired runtime.

(3) Some test cases have been hidden and are not displayed to 
prevent hardcoding of the solutions.
(4) If you have difficulties with the task, read the following
pages from Cormen (Introduction to algorithms third edition) pp.
384-389 (from the subitem ""overlapping subproblems"") and/or
https://en.wikipedia.org/wiki/Overlapping_subproblems.","int calc(int N, int[][] A){
    return null;
}","import java.util.Arrays;
import java.util.ArrayList;
import java.lang.Math;
import java.util.concurrent.ThreadLocalRandom;

public class __tester__ {
    static String SEPARATOR = ""#<ab@17943918#@>#"";
    {{ STUDENT_ANSWER }}
    public String studentAnswer = ""{{ STUDENT_ANSWER | replace({'\r': '', '\n': ''}) | e('java') }}"";
    public static void main(String[] args) {
        __tester__ main = new __tester__();
        main.runTests();
    }
    public static String sol_calc(int A[], int B[]){
    int []C = new int[B.length+1];
    for(int i=0;i<A.length;i++)
        C[A[i]]++;
    StringBuilder sol = new StringBuilder();
    for(int i=0;i<B.length;i++)
    {
        if(C[i] > B[i])
            sol.append('0');
        else
            sol.append('1');
    }
    return sol.toString();
}



    public void runTests() {
{% for testCase in TESTCASES %}
    {
    {{ testCase.testcode }};
    {% if not loop.last %}
    System.out.println(SEPARATOR);
    {% endif %}
    }
{% endfor %}
    }
}","int dfs(int node,ArrayList<ArrayList<Integer>> graph,int[] memo){
    if(graph.get(node).size() == 0){
        return 0;
    }
    else if(memo[node] != -1)
        return memo[node];
    else
    {
        int sol = 0;
        for (int i = 0; i < graph.get(node).size(); i++) {
            sol = Math.max(sol,dfs(graph.get(node).get(i),graph,memo) + 1);
        }
        memo[node] = sol;
        return memo[node];
    }
}

int calc(int N, int[][] A){
    ArrayList<ArrayList<Integer>> graph = new ArrayList<>(N+1);
    for (int i = 0; i <= N; i++) {
      graph.add(new ArrayList<>());
      if(i != 0)
          graph.get(0).add(i); 
    }
    for (int i = 0; i < A.length; i++) {
      int start,end;
      start = A[i][0];
      end = A[i][1];
      graph.get(start).add(end);
    }
    int[] memo = new int[N+1];
    for (int i = 0; i <= N; i++) {
      memo[i] = -1;
    }
    return dfs(0,graph,memo)-1;
}"
